# BowlingGame TDD 구현

## 1. **SRS(소프트웨어 요구사항 명세서) 작성**

### BowlingGame 규칙 및 요구사항

- 규칙
    - 기본 규칙
        - 단일 플레이어가 10개의 프레임으로 구성된 1개의 게임을 진행
        - 각 프레임에서 플레이어는 최대 2번의 투구 기회를 가짐
        - 첫 투구에서 10개 핀을 모두 쓰러뜨리면 스트라이크(X)로 기록하고, 해당 프레임에서는 더 이상 투구하지 않음
        - 두 번의 투구로 10개 핀을 모두 쓰러뜨리면 스페어(/)로 기록
    - 마지막 프레임 특별 규칙
        - 10번째 프레임에서 스트라이크를 기록하면 추가로 2번의 투구 기회를 얻음
        - 10번째 프레임에서 스페어를 기록하면 추가로 1번의 투구 기회를 얻음
        - 10번째 프레임에서 오픈 프레임(스트라이크나 스페어가 아닌 경우)이면 추가 투구 없음

- 점수 계산 요구사항
    - 기본 점수 계산
        - 시스템은 각 투구마다 쓰러뜨린 핀 수를 입력받아 기록해야 함
        - 각 프레임의 기본 점수는 해당 프레임에서 쓰러뜨린 핀의 총 개수
    - 보너스 점수 계산
        - 스트라이크의 경우, 기본 10점에 다음 2번의 투구에서 쓰러뜨린 핀 수를 보너스로 추가
        - 스페어의 경우, 기본 10점에 다음 1번의 투구에서 쓰러뜨린 핀 수를 보너스로 추가
        - 오픈 프레임의 경우, 해당 프레임에서 쓰러뜨린 핀 수만 점수로 계산 (보너스 없음)
    - 총점 계산
        - 게임의 총점은 각 프레임 점수의 합계로 계산
        - 최대 가능 점수는 300점 (모든 프레임에서 스트라이크를 기록한 경우)
        - 시스템은 현재까지의 누적 점수를 각 프레임마다 계산하고 표시해야 함

## 2. **SRS를 잘 설명할 수 있는 예제 목록 작성**

### BowlingGame 예제 시나리오

- 거터 게임 (모든 투구에서 0점)
    - 예시: 20번의 투구에서 모두 0개의 핀을 쓰러뜨린 경우
    - 기대 결과: 모든 프레임의 점수는 0점, 최종 점수도 0점

- 모든 투구에서 1개씩 (all ones)
    - 예시: 20번의 투구에서 모두 1개의 핀을 쓰러뜨린 경우
    - 기대 결과: 모든 프레임의 점수는 2점, 최종 점수 20점

- 스페어 예제:
    - 예시: 첫 프레임에서 5, 5로 스페어, 다음 투구에서 3점, 이후 모두 0점
    - 기대 결과: 첫 프레임 점수는 13점(10+3), 두 번째 프레임은 3점, 최종 점수 16점

- 스트라이크 예제:
    - 예시: 첫 프레임에서 스트라이크, 다음 투구들이 3점, 4점, 이후 모두 0점
    - 기대 결과: 첫 프레임 점수는 17점(10+3+4), 두 번째 프레임은 7점, 최종 점수 24점

- 퍼펙트 게임:
    - 예시: 모든 프레임에서 스트라이크(12번의 투구)
    - 기대 결과: 모든 프레임 점수는 30점, 최종 점수 300점

- 복합 예제:
    - 예시: X, 9/0, X, 2/8, 7/0, X, X, 9/0, X, 8/2/9
    - 프레임별 점수: 19, 9, 20, 17, 7, 29, 19, 9, 20, 19
    - 최종 점수: 168점
    - 상세 설명:
        - 1프레임(X): 10 + 9 + 0 = 19점
        - 2프레임(9/0): 9점 (스페어 아님)
        - 3프레임(X): 10 + 2 + 8 = 20점
        - 4프레임(2/8): 10 + 7 = 17점 (스페어)
        - 5프레임(7/0): 7점
        - 6프레임(X): 10 + 10 + 9 = 29점
        - 7프레임(X): 10 + 9 + 0 = 19점
        - 8프레임(9/0): 9점
        - 9프레임(X): 10 + 8 + 2 = 20점
        - 10프레임(8/2/9): 8 + 2 + 9 = 19점

## 3. **테스트 케이스 목록 작성**

### BowlingGame을 위한 테스트 리스트

가장 단순한 특수 케이스(degenerate)에서 일반적인 케이스(general)로 진행하는 테스트 리스트:

- [ ] gutter game (모든 투구에서 0점)
- [ ] all ones (모든 프레임에서 핀을 한개씩만 쓰러뜨린 경우)
- [ ] one spare (하나의 프레임만 스페어 처리하고, 다른 프레임은 open인 경우)
- [ ] one strike (하나의 프레임만 스트라이크 처리하고, 다른 프레임은 open인 경우)
- [ ] perfect game (모든 프레임에서 스트라이크)
- [ ] complex case (스트라이크, 스페어, 오픈 프레임이 섞인 복합 케이스)

## 4. **테스트 선택 및 구현(더 이상 추가할 테스트가 없을때까지)**

'<tackle-a-test>' 준수

### 4.1 gutter game 테스트 추가

첫 번째 테스트인 gutter game을 구현했습니다.

- 20번의 투구에서 모두 0개의 핀을 쓰러뜨리는 경우를 테스트
- BowlingGame 클래스에 roll(int pins)과 score() 메소드를 추가
- "fake it" 전략을 사용하여 score() 메소드는 단순히 0을 반환하도록 구현
- 테스트는 현재 통과하지만 다음 테스트에서 일반화가 필요할 것

### 4.2 all ones 테스트 추가

두 번째 테스트인 all ones를 구현했습니다.

- 20번의 투구에서 모두 1개의 핀을 쓰러뜨리는 경우를 테스트 (총 20점)
- 이전 테스트와 함께 triangulation을 통해 코드를 일반화
- totalScore 필드를 추가하여 투구한 핀 수를 누적
- roll() 메소드에서 핀 수를 totalScore에 더하고, score()에서 totalScore 반환
- 단순한 누적 방식으로 구현하여 스페어나 스트라이크 보너스는 아직 미고려

### 4.3 one spare 테스트 추가

세 번째 테스트인 one spare를 구현했습니다.

- 첫 프레임에서 5+5 스페어, 다음 투구 3점, 나머지 모두 0점인 경우를 테스트 (총 16점)
- 스페어 보너스 점수 계산을 위해 구조를 대폭 변경
- rolls 배열을 도입하여 모든 투구를 기록
- score() 메소드에서 프레임별로 스페어 여부를 확인하고 보너스 점수 계산
- isSpare() 헬퍼 메소드를 추가하여 스페어 판정 로직 분리
- 스트라이크는 아직 미고려

### 4.4 one strike 테스트 추가

네 번째 테스트인 one strike를 구현했습니다.

- 첫 프레임에서 스트라이크, 다음 투구들이 3점, 4점, 나머지 모두 0점인 경우를 테스트 (총 24점)
- 스트라이크 보너스 점수 계산을 위해 score() 메소드에 스트라이크 처리 로직 추가
- isStrike() 헬퍼 메소드를 추가하여 스트라이크 판정 로직 분리
- 스트라이크 시 다음 2번의 투구를 보너스로 추가 (10 + 3 + 4 = 17점)
- 스트라이크 프레임은 1번의 투구만 하므로 rollIndex를 1만 증가
- 일반 프레임과 스페어/스트라이크 프레임을 구분하여 처리

### 4.5 perfect game 테스트 추가

다섯 번째 테스트인 perfect game을 구현했습니다.

- 모든 프레임에서 스트라이크를 기록하는 퍼펙트 게임 케이스 (총 300점)
- 12번의 스트라이크 투구 (10번째 프레임의 추가 2번 투구 포함)
- 코드 리팩터링을 통해 가독성 향상
- strikeBonus(), spareBonus(), sumOfTwoBallsInFrame() 헬퍼 메소드로 분리
- 기존 로직은 그대로 유지하되 메소드 추출을 통해 의도를 명확히 표현
- 10번째 프레임의 특별 규칙도 기존 알고리즘으로 자연스럽게 처리됨

### 4.6 complex case 테스트 추가

마지막 테스트인 complex case를 구현했습니다.

- 스트라이크, 스페어, 오픈 프레임이 모두 섞인 복합적인 실제 게임 시나리오 (총 168점)
- 투구 패턴: X, 9/0, X, 2/8, 7/0, X, X, 9/0, X, 8/2/9
- 프레임별 점수: 19, 9, 20, 17, 7, 29, 19, 9, 20, 19
- 기존 구현된 알고리즘으로 모든 복잡한 케이스가 정확히 처리됨
- 10번째 프레임에서 스페어 후 추가 투구도 올바르게 계산
- 추가 구현 없이 모든 테스트가 통과하여 알고리즘의 완성도 확인

## TDD 완료 요약

모든 테스트 케이스를 성공적으로 구현했습니다.

### 완료된 기능
- ✅ 거터 게임 처리
- ✅ 기본 점수 계산
- ✅ 스페어 보너스 점수 계산
- ✅ 스트라이크 보너스 점수 계산
- ✅ 퍼펙트 게임 (300점) 처리
- ✅ 10번째 프레임 특별 규칙 처리
- ✅ 복합적인 실제 게임 시나리오 처리

### 최종 구현 특징
- 간결하고 명확한 알고리즘
- 적절한 메소드 분리를 통한 가독성 확보
- 모든 볼링 규칙과 보너스 점수 계산 정확히 구현
- TDD의 Red-Green-Refactor 사이클을 통한 점진적 개발

## 테스트 코드 리팩터링

### DSL 스타일 테스트 코드 개선

테스트 코드의 중복 제거와 가독성 향상을 위해 DSL(Domain Specific Language) 패턴을 적용했습니다.

**개선 사항:**
- Fluent Interface 패턴을 통한 자연스러운 테스트 작성
- `assertScore(expectedScore).when().roll().rollMany()` 형태의 체이닝
- 테스트 시나리오를 읽기 쉬운 형태로 표현
- 중복된 BowlingGame 생성과 assertEquals 로직 제거
- rollMany() 헬퍼 메소드로 반복 투구 간소화

**DSL 구조:**
- `GameScenario`: 기대 점수와 게임 인스턴스 관리
- `GameBuilder`: 투구 동작을 체이닝 방식으로 구성
- `assertScore()`: 테스트 시작점 제공
- `when()`: 테스트 실행 단계 시작
- `roll()`, `rollMany()`: 투구 동작 수행

**가독성 향상:**
- 각 테스트가 "기대점수를 설정하고, 투구를 수행한다"는 자연스러운 흐름으로 표현
- 주석을 통해 각 투구의 의미(스트라이크, 스페어, 보너스 등) 명확히 표시
- 복잡한 케이스도 직관적으로 이해 가능한 형태로 작성
