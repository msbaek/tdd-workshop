# WordWrap 기능 구현

## Related Claude Link
- https://claude.ai/share/ed65a36f-d840-4d16-8408-078485308388

## 전체적인 절차

## 1. **SRS(소프트웨어 요구사항 명세서) 작성**

## 2. **SRS를 잘 설명할 수 있는 예제 목록 작성**

## 3. **테스트 케이스 목록 작성**

## 4. **테스트 리스트에서 테스트 선택해서 테스트 추가하기(더 이상 추가할 테스트가 없을때까지)**

## 1. SRS(소프트웨어 요구사항 명세서) 작성

### WordWrap 규칙 및 요구사항

- **입력 요구사항**
    - 문자열과 길이(width)라는 두 개의 인수를 받음
    - width는 0보다 큰 정수
    - 문자열은 null이거나 빈 문자열일 수 있음

- **기본 규칙**
    - 함수는 문자열을 반환하되, 어떤 줄도 width보다 길지 않도록 적절한 위치에 줄바꿈(`\n`)을 삽입
    - 문자열이 null이거나 빈 문자열("")이면 빈 문자열("")을 반환
    - 연속된 공백들은 하나의 공백으로 합침
    - 입력 문자열에는 탭이나 기존 줄바꿈 문자가 없다고 가정

- **줄바꿈 규칙**
    - 단어 경계(공백)에서 줄바꿈을 우선적으로 시도
    - 워드 프로세서처럼 한 줄의 마지막 공백을 새 줄로 바꾸어 줄을 끊음
    - 단어의 길이가 width보다 크다면 단어를 강제로 자름 (하이픈 없이)
    - 결과 문자열의 마지막에는 줄바꿈 문자를 추가하지 않음

- **출력 요구사항**
    - 반환되는 문자열의 각 줄은 width 이하의 길이를 가져야 함
    - 줄바꿈은 `\n` 문자로 표현
    - 마지막 줄의 끝에는 줄바꿈 문자를 포함하지 않음

## 2. SRS를 잘 설명할 수 있는 예제 목록

### 기본 예제들

- **예제1: 빈 문자열/null 처리**
    - 입력: ("", 5) 또는 (null, 5)
    - 기대 결과: ""

- **예제2: width보다 짧은 단일 단어**
    - 입력: ("word", 10)
    - 기대 결과: "word"

- **예제3: width와 같은 길이의 단어**
    - 입력: ("hello", 5)
    - 기대 결과: "hello"

- **예제4: 공백으로 구분된 단어들 (줄바꿈 필요 없음)**
    - 입력: ("hello world", 15)
    - 기대 결과: "hello world"

- **예제5: 공백에서 줄바꿈이 필요한 경우**
    - 입력: ("hello world", 7)
    - 기대 결과: "hello\nworld"

- **예제6: width보다 긴 단어 강제 분할**
    - 입력: ("programming", 5)
    - 기대 결과: "progr\nammin\ng"

- **예제7: 연속된 공백 처리**
    - 입력: ("hello    world", 12)
    - 기대 결과: "hello world"

- **예제8: 여러 줄에 걸친 복잡한 텍스트**
    - 입력: ("The quick brown fox jumps over the lazy dog", 10)
    - 기대 결과: "The quick\nbrown fox\njumps over\nthe lazy\ndog"

## 3. 테스트 케이스 목록

가장 단순한 특수 케이스(degenerate)에서 일반적인 케이스(general)로 진행하는 테스트 리스트:

- [ ] 빈 문자열 처리
- [ ] null 문자열 처리  
- [ ] width보다 짧은 단일 단어
- [ ] width와 같은 길이의 단일 단어
- [ ] 줄바꿈이 필요 없는 여러 단어
- [ ] 공백에서 줄바꿈이 필요한 경우
- [ ] width보다 긴 단어 강제 분할
- [ ] 연속된 공백 처리
- [ ] 여러 줄에 걸친 복잡한 텍스트

## 4. 테스트 리스트에서 테스트 선택해서 테스트 추가하기

### 4.1 빈 문자열 처리 테스트 추가

빈 문자열 입력 시 빈 문자열을 반환하는 기본 동작 구현

가장 단순한 degenerate 케이스로 시작. WordWrap.wrap() 메서드를 생성하고 빈 문자열을 반환하도록 구현.
테스트는 assertThat().isEmpty()를 사용하여 간단히 검증.

### 4.2 null 문자열 처리 테스트 추가

null 입력 시 빈 문자열을 반환하는 예외 처리 구현

null 체크 조건을 추가하여 NullPointerException을 방지.
기존 빈 문자열 처리와 동일한 결과를 반환하도록 조건문을 확장.

### 4.3 width보다 짧은 단일 단어 테스트 추가

단일 단어가 width보다 짧을 때 그대로 반환하는 기본 동작 구현

fake it 전략에서 벗어나 실제 텍스트를 반환하도록 구현.
null/빈 문자열이 아닌 경우 입력 텍스트를 그대로 반환하는 조건 추가.

### 4.4 width와 같은 길이의 단일 단어 테스트 추가

단일 단어가 width와 정확히 같은 길이일 때 그대로 반환하는 동작 확인

기존 구현으로 이미 성공하는 테스트. 경계 조건 확인을 위한 안전장치 역할.
단어 길이가 width와 정확히 일치할 때도 줄바꿈 없이 반환됨을 검증.

### 4.5 줄바꿈이 필요 없는 여러 단어 테스트 추가

여러 단어로 구성된 텍스트가 width 내에 수용될 때 그대로 반환하는 동작 확인

기존 구현으로 이미 성공하는 테스트. 공백이 포함된 텍스트 처리 확인.
다음 테스트에서 진짜 줄바꿈 로직이 필요해질 것으로 예상.

### 4.6 공백에서 줄바꿈이 필요한 경우 테스트 추가

텍스트가 width를 초과할 때 공백 위치에서 줄바꿈을 삽입하는 핵심 로직 구현

실제 word wrapping 기능의 핵심 구현. lastIndexOf를 사용해 width 내 마지막 공백을 찾아 줄바꿈 처리.
텍스트 길이 체크와 공백 위치 검색을 통한 기본적인 word wrapping 알고리즘 완성.

### 4.7 width보다 긴 단어 강제 분할 테스트 추가

공백이 없는 긴 단어를 width 단위로 강제 분할하는 재귀적 처리 구현

공백이 발견되지 않을 때 강제로 width에서 자르고 나머지 부분을 재귀 호출로 처리.
recursive wrap 호출을 통해 남은 텍스트를 계속 처리하는 완전한 word wrapping 알고리즘 구현.

### 4.8 연속된 공백 처리 테스트 추가

연속된 공백을 하나의 공백으로 정규화하는 전처리 로직 구현

replaceAll("\\s+", " ")을 사용하여 연속된 공백을 하나로 합침.
공백 뒤 텍스트 처리에서도 재귀 호출을 추가하여 여러 줄 처리 개선.

### 4.9 여러 줄에 걸친 복잡한 텍스트 테스트 추가

긴 문장을 여러 줄에 걸쳐 자동으로 분할하는 종합적인 기능 검증

기존 재귀적 구현으로 이미 성공하는 테스트. 모든 word wrapping 기능이 복합적으로 작동함을 확인.
공백 위치 검색, 재귀적 분할, 각 라인 trim 처리가 모두 조화롭게 동작하는 완전한 알고리즘 검증.

## 발견한 요구사항

TDD 과정을 통해 구체화되고 명확해진 WordWrap의 실제 요구사항:

### 1. 입력/출력 기본 규칙
- **null 또는 빈 문자열** → 빈 문자열 반환
- **width 이하 길이** → 그대로 반환 (단, 각 라인은 trim 적용)

### 2. 줄바꿈 우선순위 규칙
1. **공백 위치 우선**: width 내에서 가장 뒤쪽 공백에서 줄바꿈
2. **강제 분할**: 공백이 없으면 width 위치에서 강제로 자름

### 3. 공백 처리 핵심 원칙
- **분할 시**: 공백 조작하지 않음 (원본 그대로 자름)
- **반환 시**: 각 라인마다 leading/trailing 공백 제거 (trim)

### 4. 재귀 처리 규칙
- 남은 텍스트가 있으면 동일한 로직으로 재귀 처리
- 각 재귀 호출 결과도 동일한 trim 규칙 적용

### 5. 결과 형태
- 줄바꿈은 `\n` 문자 사용
- 마지막 줄 끝에는 줄바꿈 없음
- 각 라인은 leading/trailing 공백 없음

### 6. 핵심 통찰
- **Software ain’t like that. We do the work to discover what work needs doing.**
  - [Scope Management 101 - by Kent Beck](https://tidyfirst.substack.com/p/scope-management-101)
이러한 규칙들이 처음부터 명확했다면 TDD 과정에서 중간에 공백 처리 방식을 변경하거나 헤매지 않았을 것임. 
**"분할은 원본 그대로, 반환은 깔끔하게"**라는 일관된 원칙이 가장 중요한 발견.